// lexical
// -------

comments                            : oneline-comment
                                    | multiline-comment
                                    ;

oneline-comment                     : '#'   unicode characters opt end-of-line                                          --- python comments
                                    | '//'  unicode characters opt end-of-line                                          --- c, c++, java, etc. comments
                                    | '---' unicode characters opt end-of-line                                          --- ada comments
                                    ;

multiline-comment-opt               : multiline-comment
                                    | e(psilon)
                                    ;

multiline-comment                   : '/* unicode characters opt(except '*/' combination)  multiline-comment-opt  unicode characters opt(except '*/' combination) '*/'
                                    ;

whitespace-characters               : whitespace-character
                                    | whitespace-characters whitespace-character
                                    ;

whitespace-character                : unicode character of class Zs
                                    | horizontal tab character (U+0009)
                                    | vertical tab character (U+000B)
                                    | form feed character (U+000C)
                                    ;

end-of-line                         : \u000D                                                                            --- \r
                                    | \u000A                                                                            --- \n
                                    | \u000D \u000A                                                                     --- \r\n
                                    | \u000A \u000D                                                                     --- \n\r
                                    | \u0085
                                    | \u2028
                                    | \u2029
                                    | end-of-file
                                    ;

end-of-file                         : \u0000
                                    | \u001A
                                    ;

indent                              : '  '                                                                              --- 2 spaces
                                    | '    '                                                                            --- 4 spaces
                                    | '        '                                                                        --- 8 spaces
                                    ;



// code points
// \u + 4 hex digits                                                                                                    --- unicode BMP
// \U + 8 hex digits                                                                                                    --- unicode astral planes (full set)
universal-character-name            : '\u' hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
                                    | '\U' hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
                                    ;

letter-character                    : unicode character of classes Lu, Ll, Lt, Lm, Lo, or Nl
                                    | universal-character-name representing a character of classes Lu, Ll, Lt, Lm, Lo, or Nl
                                    ;

decimal-digit_character             : unicode character of class Nd
                                    | universal-character-name representing a character of class Nd
                                    ;

connecting-character                : unicode character of class Pc
                                    | universal-character-name representing a character of class Pc
                                    ;

combining-character                 : unicode character of classes Mn or Mc
                                    | universal-character-name representing a character of classes Mn or Mc
                                    ;

formatting_character                : unicode character of class Cf
                                    | universal-character-name representing a character of class Cf
                                    ;

binary-digit                        : '0' '1'
                                    ;

octal-digit                         : '0' '1' '2' '3' '4' '5' '6' '7'
                                    ;

nonzero-decimal-digit               : '1' '2' '3' '4' '5' '6' '7' '8' '9'
                                    ;

decimal-digit                       : '0' '1' '2' '3' '4' '5' '6' '7' '8' '9'
                                    ;

hexa-decimal-digit                  : '0' '1' '2' '3' '4' '5' '6' '7' '8' '9' 'a' 'b' 'c' 'd' 'e' 'f' 'A' 'B' 'C' 'D' 'E' 'F'
                                    ;



escape-characters                   : simple-escape-character
                                    | octal-escape-characters
                                    | hexadecimal-escape-characters
                                    ;

simple-escape-character             : '\'' '\"' '\\' '\a' '\b' '\f' '\n' '\r' '\t' '\v'
                                    ;

octal-escape-characters             : '\' octal-digit
                                    | '\' octal-digit octal-digit
                                    | '\' octal-digit octal-digit octal-digit
                                    ;

hexadecimal-escape-characters       : '\x' hexadecimal-digit
                                    | '\x' hexadecimal-digit hexadecimal-digit
                                    | '\x' hexadecimal-digit hexadecimal-digit hexadecimal-digit
                                    | '\x' hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
                                    | '\x' hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
                                    | '\x' hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
                                    | '\x' hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
                                    | '\x' hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
                                    ;

underscore-characters-opt           : underscore-characters
                                    | e(psilon)
                                    ;

underscore-characters               : underscore-character
                                    | underscore-characters underscore-character
                                    ;

underscore-character                : '_' (the underscore character U+005F)
                                    | universal-character-name representing the character U+005F
                                    ;


literal                             : integer-number-literal
                                    | real-number-literal
                                    | string-literal
                                    | boolean-literal
                                    ;

integer-number-literal              : binary-number-literal
                                    | octal-number-literal
                                    | decimal-number-literal
                                    | hexadecimal-number-literal
                                    ;

binary-number-literal               : '0b' binary-digits
                                    | '0B' binary-digits
                                    ;

binary-digits                       : binary-digit
                                    | binary-digits underscore-characters-opt binary-digit
                                    ;

octal-number-literal                : '0'
                                    | octal-number-literal underscore-characters-opt octal-digit
                                    ;

decimal-number-literal              : nonzero-decimal-digit
                                    | decimal-number-literal underscore-characters-opt decimal-digit
                                    ;

decimal-digits-opt                  : decimal-digits
                                    | e(psilon)
                                    ;

decimal-digits                      : decimal-digit
                                    | decimal-digits underscore-characters-opt decimal-digit
                                    ;

hexadecimal-number-literal          : '0x' hexadecimal-digits
                                    | '0X' hexadecimal-digits
                                    ;

hexadecimal-digits-opt              : hexadecimal-digits
                                    | e(psilon)
                                    ;

hexadecimal-digits                  : hexadecimal-digit
                                    | hexadecimal-digits underscore-characters-opt hexadecimal-digit
                                    ;

real-number-literal                 : decimal-real-number-literal
                                    | hexadecimal-real-number-literal
                                    ;

decimal-real-number-literal         : decimal-digits-opt '.' decimal-digits exponent-part-opt
                                    | decimal-digits '.' exponent-part-opt
                                    | decimal-digits exponent-part
                                    ;

exponent-part-opt                   : exponent-part
                                    | e(psilon)
                                    ;

exponent-part                       : 'e' sign-opt decimal-digits
                                    | 'E' sign-opt decimal-digits
                                    ;

hexadecimal-real-number-literal     : '0x' hexadecimal-digits-opt '.' hexadecimal-digits binary-exponent-part-opt
                                    | '0X' hexadecimal-digits-opt '.' hexadecimal-digits binary-exponent-part-opt
                                    | '0x' hexadecimal-digits '.' binary-exponent-part-opt
                                    | '0X' hexadecimal-digits '.' binary-exponent-part-opt
                                    | '0x' hexadecimal-digits binary-exponent-part
                                    | '0X' hexadecimal-digits binary-exponent-part
                                    ;

binary-exponent-part-opt            : binary-exponent-part
                                    | e(psilon)
                                    ;

binary-exponent-part                : 'p' sign-opt decimal-digits
                                    | 'P' sign-opt decimal-digits
                                    ;

sign-opt                            : '+'
                                    | '-'
                                    | e(psilon)
                                    ;

string-literal                      : ''' string-characters-opt (except \' (U+0027), \\ (U+005C)) '''
                                    | '"' string-characters-opt (except \" (U+0022), \\ (U+005C)) '"'
                                    | r''' string-characters-opt (except \' (U+0027)) '''                               --- raw/verbatim string ' text '
                                    | r'"' string-characters-opt (except \" (U+0022))'"'                                --- raw/verbatim string " text "
                                    ;

string-characters-opt               : string-characters
                                    | e(psilon)
                                    ;

string-characters                   : string-character
                                    | string-characters string-character
                                    ;

string-character                    : unicode character opt
                                    | escape-characters
                                    | universal-character-name
                                    ;

boolean-literal                     : 'true'
                                    | 'false'
                                    ;


identifiers                         : identifier
                                    | identifiers ',' identifier
                                    ;

identifier                          : identifier-start-character identifier-part-characters-opt                         --- $ is internal character (tmp), cannot be used in public
                                    ;

identifier-start-character          : letter-character
                                    | underscore-characters
                                    ;


identifier-part-characters          : identifier-part-character
                                    | identifier-part-characters identifier-part-character
                                    ;

identifier-part-character           : letter-character
                                    | decimal-digit-character
                                    | connecting-character
                                    | combining-character
                                    | formatting-character
                                    ;

fully-qualified-identifier          : identifier
                                    | fully-qualified-identifier '.' identifier
                                    ;


keyword                             : 'byte' 'integer' 'real' 'string' 'boolean'
                                    | 'c'
                                    | 'true' 'false'
                                    | 'enum'
                                    | 'struct'
                                    | 'extends'
                                    | 'const' 'readonly'
                                    | 'partial'
                                    | 'if' 'else' 'for' 'while'
                                    | 'switch' 'case' 'when' ????
                                    | 'continue' 'break' 'return' 'goto'
                                    | 'import'
                                    | 'namespace'
                                    | 'block' 'leave'                                                                   --- leave my_block - exits the current block from any statment, including nested loops
                                    | 'is'
                                    | 'and' 'or' 'not'
                                    | 'lazy'
                                    | 'pass' 'noop'
                                    | 'fn'
                                    | 'returns'
                                    | 'unchecked' 'checked'
                                    ;

punctuator                          : ':' '..' '...' ',' '[' ']' '(' ')'
                                    ;

operator                            : '+' '-' '*' '/' '>>' '<<' '=' '==' '!=' '<' '<=' '>' '>=' '&' '&&' '|' '||' '^' '!'
                                    | 'is' 'and' 'or' 'not'
                                    ;

assignment-operator                 : '=' '+=' '-=' '*=' '/=' '>>=' '<<=' '&=' '|=' '^='
                                    ;



// syntax
// ------

type-opt                            : type
                                    | e(psilon)
                                    ;

type                                : integral-type array-specifier-opt
                                    | fully-qualified-identifier type-arguments-opt array-specifier-opt
                                    ;

integral-type-opt                   : integral-type
                                    | e(psilon)
                                    ;

integral-type                       : 'byte'                                                                            --- 0-255
                                    | 'integer'                                                                         --- int64
                                    | 'real'                                                                            --- double
                                    | 'string'                                                                          --- " 'c' "  ' "c" '
                                    | 'boolean'                                                                         --- true false
                                    ;

type-arguments-opt                  : '<' type-arguments '>'
                                    | e(psilon)
                                    ;

type-arguments                      : type-argument                                                                     --- type-argument (',' type-argument)*
                                    | type-arguments ',' type-argument
                                    ;

type-argument                       : type
                                    ;

type-parameters-opt                 : '<' type-parameters '>'
                                    | e(psilon)
                                    ;

type-parameters                     : type-parameter                                                                    --- type-parameter (',' type-parameter)*
                                    | type-parameters ',' type-parameter
                                    ;

type-parameter                      : fully-qualified-identifier
                                    ;

array-specifier-opt                 : array-specifier
                                    | e(psilon)
                                    ;

array-specifier                     : '[' array-dimensions ']' c-opt                                                    --- checked array, row based, optionally column based
                                    ;

array-dimensions                    : array-dimension                                                                   --- array-dimension (',' | ';' array-dimension)*
                                    | array-dimensions ',' array-dimension                                              --- all ',' as a separator of a dimension
                                    | array-dimensions ';' array-dimension                                              --- a;; ';' as a separator of a dimension
                                    ;

array-dimension                     : expression                                                                        --- expression ('..' expression)?
                                    | expression '..' expression
                                    ;

c-opt                               : 'c'                                                                               --- column based array specifier
                                    | e(psilon)
                                    ;

type-modifiers-opt                  : type-modifiers
                                    | e(psilon)
                                    ;

type-modifiers                      : type-modifier                                                                     --- type-modifier (type-modifier)*
                                    | type-modifiers type-modifier
                                    ;

type-modifier                       : const-type-modifier                                                               --- initialized at the point of declaration, mutual exclusive
                                    | readonly-type-modifier                                                            --- initialized at any point only once, mutual exclusive
                                    ;

const-type-modifier                 : 'const'
                                    ;

readonly-type-modifier              : 'readonly'
                                    ;


initializer                         : expression-initializer
                                    | array-initializer
                                    | struct-initializer
                                    ;

expression-initializer              : expression
                                    ;

array-initializer                   : array-member-initializations
                                    ;

array-member-initializations        : array-member-initialization                                                       --- array-member-initialization (',' | ';' array-member-initialization)*
                                    | array-member-initializations ',' array-member-initialization
                                    | array-member-initializations ';' array-member-initialization
                                    ;

array-member-initialization         : array-dimension-initialization                                                    --- array-dimension-initialization (' ' | ',' array-dimension-initialization)*
                                    | array-member-initialization ' ' array-dimension-initialization                    --- if dimensions are delimited with ',', whitespace(s)
                                    | array-member-initialization ',' array-dimension-initialization                    --- if dimensions are delimited with ';'
                                    ;

array-dimension-initialization      : initializer
                                    ;

struct-initializer                  : struct-member-initializations
                                    ;

struct-member-initializations       : struct-member-initialization                                                      --- struct-member-initialization (',' struct-member-initialization)*
                                    | struct-member-initializations ',' struct-member-initialization
                                    ;

struct-member-initialization        : initializer
                                    | identifier '=' initializer
                                    ;


compilation-unit                    : compilation-unit-declarations-opt
                                    ;

compilation-unit-declarations-opt   : compilation-unit-declarations
                                    | e(psilon)
                                    ;

compilation-unit-declarations       : compilation-unit-declaration
                                    | compilation-unit-declarations compilation-unit-declaration
                                    ;

compilation-unit-declaration        : import-declarations
                                    | namespace-alias-definitions
                                    | namespace-definitions
                                    ;

import-declarations                 : import-declaration
                                    | import-declarations import-declaration
                                    ;

import-declaration                  : 'import' fully-qualified-identifier
                                    ;

namespace-alias-definitions         : namespace-alias-definition                                                        --- namespace-alias-definition (namespace-alias-definition)*
                                    | namespace-alias-definitions namespace-alias-definition
                                    ;

namespace-alias-definition          : 'namespace' identifier '=' fully-qualified-identifier
                                    ;

namespace-definitions               : namespace-definition
                                    | namespace-definitions namespace-definition
                                    ;

namespace-definition                : 'namespace' fully-qualified-identifier namespace-body-opt
                                    ;

namespace-body-opt                  : namespace-body
                                    | e(psilon)
                                    ;

namespace-body                      : struct-declarations
                                    | enum-declarations
                                    | function-declarations
                                    ;

struct-declarations                 : struct-declaration
                                    | struct-declarations struct-declaration
                                    ;

struct-declaration                  : identifier 'struct' type-parameters-opt partial-opt struct-members-opt
                                    ;

partial-opt                         : 'partial'
                                    | e(psilon)
                                    ;

struct-extension-opt                : struct-extension
                                    | e(psilon)
                                    ;

struct-extension                    : 'extends' base-structs                                                            --- only one name can be declared in the structs' hierarchy
                                    ;

base-structs                        : base-struct
                                    | base-structs ',' base-struct
                                    ;

base-struct                         : fully-qualified-identifier type-parameters-opt
                                    ;

struct-members-opt                  : struct-members
                                    | e(psilon)
                                    ;

struct-members                      : struct-member                                                                     --- NEWLINE INDENT (struct-member)* DEDENT
                                    | struct-members ',' struct-member
                                    ;

struct-member                       : identifiers ':' type type-modifiers-opt
                                    | identifiers ':' type type-modifiers-opt '=' initializer
                                    ;


enum-declarations                   : enum-declaration
                                    | enum-declarations enum-declaration
                                    ;

enum-declaration                    : identifier 'enum' integral-type-opt enum-members-opt                              --- default integer
                                    ;

enum-members-opt                    : enum-members
                                    | e(psilon)
                                    ;

enum-members                        : enum-member                                                                       --- NEWLINE INDENT (enum-member)* DEDENT
                                    | enum-members ',' enum-member
                                    ;

enum-member                         : identifier
                                    | identifier '=' literal
                                    | fully-qualified-identifier '..' fully-qualified-identifier                        --- fully-qualified-identifier must be from enum members
                                    ;


function-declarations               : function-declaration
                                    | function-declarations function-declaration
                                    ;

function-declaration                : identifier 'fn' type-parameters-opt '(' function-parameters-opt ')' function-returns-opt function-body
                                    ;                                                                                   --- if no function-returns that means return types are inferred

function-parameters-opt             : function-parameters
                                    | e(psilon)
                                    ;

function-parameters                 : function-parameter
                                    | function-parameters ',' function-parameter
                                    ;

function-parameter                  : identifier ':' type type-modifiers-opt
                                    | identifier ':' type type-modifiers-opt lazy-opt '=' initializer
                                    | '...'                                                                             --- must be the last
                                    ;

lazy-opt                            : 'lazy'                                                                            --- lazy parameters evaluation
                                    | e(psilon)
                                    ;

function-returns-opt                : 'returns' function-returns
                                    | e(psilon)
                                    ;

function-returns                    : function-return
                                    | function-returns ',' function-return
                                    ;

function-return                     : type
                                    ;

function-body                       : function-declarations                                                             --- nested functions
                                    | statements
                                    ;

lambda-declaration                  : 'lambda' type-parameters-opt '(' function-parameters-opt ')' function-returns-opt function-body
                                    ;

lambda-body                         : '(' statements-opt ')'                                                            --- always acts as multiline definition ()
                                    ;


statements-opt                      : statements
                                    | e(psilon)
                                    ;

statements                          : statement                                                                         --- NEWLINE INDENT (statement)+ DEDENT
                                    | statements statement
                                    ;

statement                           : declaration-statement
                                    | with-statement
                                    | expression-statement
                                    | if-statement
                                    | while-statement
                                    | for-statement
                                    | break-statement
                                    | continue-statement
                                    | return-statement
                                    | goto-statement
                                    | label-statement
                                    | finally-statement
                                    | namespace-alias-definition
                                    | import-declaration                                                                --- this statement might be available only in JIT mode
                                    | 'noop'
                                    | 'pass'
                                    | NEWLINE INDENT 'checked' DEDENT                                                   --- turn on cheking semantics
                                    | NEWLINE INDENT 'uchecked' DEDENT                                                  --- turn off cheking semantics
                                    ;

declaration-statement               : variable-declaration
                                    | struct-declaration
                                    | enum-declaration
                                    ;

variable-declaration                : identifiers ':' type type-modifiers-opt                                           --- θ, φ, π : real
                                    | identifiers ':' type-opt type-modifiers-opt lazy-opt '=' initializer              --- θ, φ, π : real const = 0.1
                                    | identifiers ':' initializer                                                       --- θ, φ, π : 0.1
                                    ;

with-statement                      : 'with' expressions statements                                                     --- expression evaluates to struct(s) instance(s)
                                    ;

expression-statement                : assignment-expression
                                    ;

if-statement                        : 'if' expression statements                                                        --- expression evaluates to boolean
                                    | 'if' expression statements 'else' statements
                                    ;

while-statement                     : 'while' expression statements                                                     --- expression evaluates to boolean
                                    ;

for-statement                       : 'for' variable-declaration ':' expression statements                              --- expression acts as generator
                                    ;

break-statement                     : 'break'                                                                           --- innner most
                                    ;

continue-statement                  : 'continue'                                                                        --- innner most
                                    ;

return-statement                    : 'return' expression
                                    ;

goto-statement                      : 'goto' identifier                                                                 --- inter-procedure only
                                    ;

label-statement                     : identifier ':'                                                                    --- inter-procedure only
                                    | identifier ':' statement
                                    ;

finally-statement                   : 'finally' statements
                                    ;


expressions                         : expression
                                    | expressions ',' expression
                                    ;

primary-expression                  : literal                                                                           --- 5, 'text'
                                    | fully-qualified-identifier type-arguments-opt                                     --- geo.point<T>, point<real>
                                    | '(' expression ')'
                                    ;

expression                          : primary-expression
                                    | '+' expression
                                    | '-' expression
                                    | '!' expression
                                    | 'not' expression
                                    | '++' expression                                                                   --- expression evaluates to integer
                                    | '--' expression                                                                   --- expression evaluates to integer
                                    | expression '.' identifier                                                         --- member access
                                    | expression '[' arguments-opt ']                                                   --- array element access
                                    | expression '(' arguments-opt ')'                                                  --- function invocation
                                    | expression '++'                                                                   --- expression evaluates to integer
                                    | expression '--'                                                                   --- expression evaluates to integer
                                    ;

multiplicative-expression           : expression
                                    | multiplicative-expression '*' expression
                                    | multiplicative-expression '/' expression
                                    | multiplicative-expression '%' expression                                          --- both sides must be integers
                                    ;

additive-expression                 : multiplicative-expression
                                    | additive-expression '+' multiplicative-expression
                                    | additive-expression '-' multiplicative-expression
                                    ;

shift-expression                    : additive-expression
                                    | shift-expression '<<' additive-expression                                         --- both sides must be integers
                                    | shift-expression '>>' additive-expression                                         --- both sides must be integers
                                    ;

relational-expression               : relational-expression '<' shift-expression
                                    | relational-expression '>' shift-expression
                                    | relational-expression '<=' shift-expression
                                    | relational-expression '>=' shift-expression
                                    | relational_expression 'is' type
                                    ;

equality-expression                 : relational-expression
                                    | equality-expression '==' relational-expression
                                    | equality-expression '!=' relational-expression
                                    ;

and-expression                      : equality-expression
                                    | and-expression '&' equality-expression
                                    ;

exclusive-or-expression             : and-expression
                                    | exclusive-or-expression '^' and-expression
                                    ;

inclusive-or-expression             : exclusive-or-expression
                                    | inclusive-or-expression '|' exclusive-or-expression
                                    ;

logical-and-expression              : inclusive-or-expression
                                    | logical-and-expression '&&' inclusive-or-expression
                                    | logical-and-expression 'and' inclusive-or-expression
                                    ;

logical-or-expression               : logical-and-expression
                                    | logical-or-expression '||' logical-and-expression
                                    | logical-or-expression 'or' logical-and-expression
                                    ;

conditional-expression              : logical-or-expression
                                    | logical-or-expression '?' expression ':' conditional-expression
                                    ;

assignment-expression               : expression assignment-operator assignment-expression                              --- assignment occurs only as a separate statement
                                    ;

arguments-opt                       : arguments
                                    | e(psilon)
                                    ;

arguments                           : argument
                                    | arguments ',' argument
                                    ;

argument                            : argument-name-opt expression
                                    ;

argument-name-opt                   : argument-name
                                    | e(psilon)
                                    ;

argument-name                       : identifier ':'
                                    ;













//
compilation composition
    imports all deps into one compilation-unit and then processed

                              program arcturus

                 namespace N1                   namespace N2

    package1                      package2                         package3
        module1                       module1                          module1
        module2                       module2                          module2
        module3                       module3                          module3

    package(physical) - spans compilation-units (might be files) - distribution unit
        modules
            module1 - compilation-unit1 (file)
            ...
            moduleN - compilation-unitN (file)

    namespace(logical) - spans packages



namespace
    namespace sample
        namespace nested
    using sample.nested
    import sample.nested
    a : sample.nested.point

    alias
        using sn = sample.nested
        import sample.nested as sn
    a : sn.point

    namespace n1.n2.n3
        namespace w
    a : n1.n2.n3.w.point



comment
    #   single line comment
    //  single line comment
    --- single line comment
    /* /* miltiline nested comment */ */



declarations:
    let a : integer | string  --- first assignement freezes type

    byte
        flags: byte = 0xDA
        bits : byte = 0b1_0_00_10_1
        line : byte [0..256]

    boolean
        flag: boolean                               default = false
        flag: boolean = true

    number
        integer
            i, j, k : integer                        uninitialized, all have the same value which is default - 0
            i, j, k : integer = 1_2_345_678_90       initialization, all have the same value
            i, j, k : integer = 1'2'34'5'67'890      initialization, all have the same value
            i, j, k : integer const = 100            initialization of constants, all have the same value, must be assigned
            i, j, k : const integer = 100
            i, j, k : 0                              initialization, all have the same value, type integer is inferred
            i, j, k : const = 100                    initialization of constants, all have the same value, type integer is inferred
            i, j, k : integer readonly               uninitialized variables of read-only constants, might be called later after declaration, all have the same value
            i, j, k : integer readonly = 100         initialization of read-only constants, might be called later after declaration, all have the same value
            i, j, k : readonly integer = 100
            i, j, k : integer -10 .. 100             uninitialized, all have the same range [-10:100], range's bounddary must be const expression
            i, j, k : integer -10 .. 100 = 5         initialized range, initialized with 5, all have the same vaue in the range

            i, j, k = foo()                          deconstruction, types are inferred from foo() return values
            i, j, k = 10

            row/column access (default)
            column/row access
            [] - checked(default)
            () - unchecked
            c  - column based suffix
            a, b, c: integer [1..5]              =  3,4                 ----- checked array, row based
            a, b, c: integer (1..5)              =  3,4                 ----- unchecked array, row based
            a, b, c: integer [1..5; -1..8; 0..4] =  3,4; 2,3,3; 5,6,6   ---- 3D
            a, b, c: integer [1..5; -1..8; 0..4] =  ( 3,4; 2,3,3;
                                                        5,6,6 )
            a, b, c: integer [1..5; -1..8; 0..4] =  ( 3,4; 2,3,3; 5,6,6 )
            a, b, c: integer [1..5, -1..8, 0..4] =  ( 3 4, 2 3 3, 5 6 6 )
            a, b, c: integer [1..5, -1..8, 0..4] =  ( (3,4), (2,3,3), (5,6,6) )
            a, b, c: integer [1..5] c            =  3,4                 ----- checked array, column based
            a, b, c: integer (1..5) c            =  3,4                 ----- unchecked array, column based

            a[2, -1, 0] = 5
            a[2, -1, 0] = 5

            a : integer [0..2; 0..3; 0..4] = ( ( ( 3, 4, 2, 3 ), (0, -3, 9, 11), (23, 12, 23, 2) ), ( ( 13, 4, 56, 3 ), ( 5, 9, 3, 5 ), ( 3, 1, 4, 9 ) ) )

            slices, APL?? and python
            slice = a[-1:1; -5:45;]
            slice = a[-1:1, -5:45]
            slice = a[-1..1, -5..45]

        real
            θ, φ, π : real
            θ, φ, π : 0.1                           inferred as real
            θ, φ, π : real = 0.1
            θ, φ, π : real const = 0.1
            θ, φ, π : const real = 0.1
            θ, φ, π : real readonly = 0.1
            θ, φ, π : readonly real = 0.1
            π       : real const = 3.14159
            θ, φ    : real -π .. +π                 π must be const expression
            θ, φ    : real -π .. +π = π/2           might be initialized with expression
            θ, φ    : const real -π .. +π = π/2     might be initialized with expression
            θ, φ    : real const -π .. +π = π/2     might be initialized with expression


    string (always represented as unicode codepoints - 32 bits), " '' " or ' "" '
        name, nickname : string
        name, nickname : string = "Art"
        name, nickname : string const = "Art"       must be initialized
        name, nickname : const string = "Art"       must be initialized
        name, nickname : string readonly = "Art"
        name, nickname : readonly string = "Art"

        "path 'c:\\tmp\\arktur\\file.txt' exists"  'path "c:\\tmp\\arktur\\file.txt" exists'
        r"path 'c:\tmp\arktur\file.txt' exists"    r'path "c:\tmp\arktur\file.txt" exists'
        "path is {path}, where path is substitued by variable 'path'"
        r"path is {path}, where path is substitued by variable 'path'"
        "\' \" \n \r \t \\ \b \f \v \017 \x8C \X8C \uD83C\uDF4C \U0001f34c"
        "balance {0:.2f} is as {1:YYMMDD}"              positional
        "balance {amount:.2f} is as {today:YYMMDD}"     keyword
        "balance {0:.2f} is as {1:YYMMDD} for {user}"   positional keyword mixture
        DOES NOT support f-strings (python) or interpolated $"" (c#) strings on purpose (hard to debug)


    enum
        direction enum [integer]
            north,
            east,
            south,
            west

        numbers enum ( one, two, three,
                       forty = 40, fortyone )

        numbers enum string
            ( odin = "1", dva = "2" )           ------------ when non-integer - all must be initialized
        numbers enum real
            ( r1 = 0.23, r2 = 3.45 )            ------------ when non-integer - all must be initialized
        days enum integer ( monday, tuesday, wednesday,
                            thursday, friday, saturday, sunday )
        workdays enum days
            monday .. friday
        weekend enum days
            saturday .. sunday
        weekend enum days ( saturday .. sunday )
        odddays enum days
            monday,
            tuesday .. wednesday,
            friday,
            weekend


    struct [<Ts>][partial] [readonly|const]
            [readonly ------- values can be assigned only once]
            [const ------- values must be assigned in declaration]
            each struct defines one default instance of this struct - static sentinel = default

        point struct
            x : real = 0.0,
            y : real = 0.0,
            z : real = 0.0,
            w : real = 1.0

        point<T> struct
            x : T,
            y : T,
            z : T,
            w : real = 1.0

        point<T> struct
            x, y, z : T
            w : real = 1.0

        point<T> struct ( x : T, y : T,
                          z : T, w : real = 1.0 )

        node<T> struct
            value : T,
            point : point<T>,
            next : node,          ---- when parse mark as ref field, by default it set to the 'default' sentinel
            prev : node

        node<T> struct
            value : T,
            point : point<T>,
            next, prev : node

        tree<T> struct
            gr_symbol : grammar.symbol
            ir_symbol : ir.symbol
            value : T,
            papa : tree
            kids : tree
            flags : byte = 0x00

        status<T, P, R, TSize integer = 64, TWeight real = 1.4, TText string = "message"> struct
            code : T,
            param : P,
            return : R,
            size : TSize,
            weight : TWeight,
            text : TText

        user struct <T> extends tree<T>
            name : string,
            age : integer,
            married : boolean = false,
            status : string = 'active',
            salary : real = 1.0

        manager<T> struct extends user<T>
            occupation : string,
            bonus : real

        boss<T> struct extends manager<T>
            rank : string,
            big_bonus : real

        myboss : boss<string> = ( name = 'Arthur', age = 50, married = true, status = 'active',
                                  salary = 10000000.0, occupation = 'R&D', bonus = 1231211.2,
                                  rank = 'highest', big_bonus = 656545234.923432 )

        pp0 : point<real>
        pp0 : point<real> = ( 1.2, 3.2,
                              5.0, 3.12 )
        pp0 : point<real> = 1.2, 3.2, 5.0, 3.12
        pp1 : point<real> = x = 1.2, y = 3.2, z = 5.0, w = 3.12
        pp2 : point<real> = z = 1.2, w = 3.2, y = 5.0, z = 3.12
        pp2 : point<real> = ( z = 1.2, w = 3.2,
                                y = 5.0, z = 3.12 )
        pp3 : point<real> = ( x = 1.2, w = 3.12 )
        pp4 : point<integer> = ( z = 1 )

        n1 : node<integer> = ( 5, pp4 )
        n1 : node<integer> = ( 5, pp4, default, default )
        n1 : node<integer> = ( value = 5, point = pp4, next = n1, prev = n1 )
        n2 : node<integer> = ( value = 5, point = ( x = 1.2, w = 3.12 ), n2, n1 ) ---
                                                    anonymous struct
        n3 : node<integer> = ( value = 5, point = get_point(), next = n3, prev = n2 )


    callable
        parameters passing method
            by value
                byte, integer, real, boolean
            by ref
                string, array, enum, struct, callable

        function
            func/proc
                name[<T>] func/proc ([params]) [lazy] [ -> (returns) | returns]
                name func/proc[<T>] ([params]) [lazy] [ [->] (returns) | returns]

                foo func(i : integer, r : real = π, s : string = "", n1 : node<integer> = ( 5, pp4 )) lazy returns i, j, k: integer, pp2 : point<real>
                foo func(i : integer, r : real = π, s : string = "", n1 : node<integer> = ( 5, pp4 )) lazy -> ( i, j, k: integer,
                                                                                                                pp2 : point<real> )
                foo(1)                  ------- after call variables i,j,k and pp2 are avaiable automatically
                i1,j1,k1,pp20 = foo(1)  ------- after call variables i,j,k and pp2 can have different names

                foo<T> func(t : T, r : real = π, s : string = "") lazy -> (i, j, k: T, pp2 : point<T>)
                    body or { body }

                foo func<T>(t : T, r : real = π, s : string = "") lazy -> (i, j, k: T, pp2 : point<T>)
                    body or { body }

                foo func<T> (t : T, r : real = π, s : string = "") lazy (T, T, T, point<T>)
                    body or { body }

                foo<real>(1.23, φ, "test")
                foo<real>(t : 1.23, s : "test", r : φ) lazy??

                foo func(i : integer,
                         r : real = π,
                         s : string = "",
                         n1 : node<integer> = ( 5, pp4 ),
                         ...) ------- variable number of params
                            lazy returns (i, j, k: integer, pp2 : point<real>)
                                 ->
                    body or { body }

                nested
                    num1 func(x : integer) -> integer
                       num2 func(y : integer) -> (integer)
                          return x * y
                       return num2
                    res = num1(10)
                    print(res(5))

                block
                    block ------ new scope
                        ...
                    block ------ new scope
                        ...


        lambda (no templates/generics)
                (t : integer, r : real = π, s : string = "") lazy -> i, j, k: real, pp2 : point<real> => expression body
                (t : integer, r : real = π, s : string = "") lazy -> (i, j, k: real, pp2 : point<real>) => { statements body }


    contracts
        interface


    statement
        selection
            if condition                                    if (condition)      ----- might be split across lines
                statements                                      { statements }  ----- free layout
            else if condition                               else if (condition)
                statements                                      { statements }
            else                                            else
                statements                                      { statements }


        case/switch

case(s):
    when 1
    when 's'
    when a is string || a is real && a is customtype


case Sensor is
    when Elevation => Record_Elevation(Sensor_Value);
    when Azimuth => Record_Azimuth (Sensor_Value);
    when Distance => Record_Distance (Sensor_Value);
    when others => null;
end case;
case Today is
    when Mon => Compute_Initial_Balance;
    when Fri => Compute_Closing_Balance;
    when Tue .. Thu => Generate_Report(Today);
    when Sat .. Sun => null;
end case;
case Bin_Number(Count) is
    when 1 => Update_Bin(1);
    when 2 => Update_Bin(2);
    when 3 | 4 =>
        Empty_Bin(1);
        Empty_Bin(2);
    when others => raise Error;
end case;

pattern matching, case/when, switch C# 8






        iteration
            for k, name in enumerate(names)                 for (k, name) in enumerate(names)
                statements                                      { statements }
            for k in 1..5    ------ next value              for k in 1..5       ------ next value
                statements                                      { statements }

            while condition  ------ expression is true      while (condition)   ------ expression is true
                statements                                      { statements }

            continue
            break
            yield ----- ??
            return
            goto



    expression



    point2d struct<T>
        x : T = 0.0,
        y : T = 0.0,

    point3d struct<T> partial extends point2d<T>
        z : T = 0.0,
        w : T = 1.0


    geometry interface
        distance : func<T>(p1 : point<T>, p2 : point<T>) -> real
        slope : func<T>(p1 : point<T>, p2 : point<T>) -> real




    
    p1 : point<real> = ( 1.2, 3.2, 5.0, 3.12 )
    p2 : point<real> = ( 1.2, 3.2, 5.0, 3.12 )
    p3 : point<real> = ( 1.2, 3.2, 5.0, 3.12 )

    with p1, p2, p3
        any method has access to p1,p2, p3, no need to pass, they will be placed in a special 'with' context with its own scope


    with (p1,
          p2 : point<real> = ( 1.2, 3.2, 5.0, 3.12 ),
          p3)
        foo() --- has access to p1,p2, p3, no need to pass, name collisions are resolved/reported in usual way





field-initialization-expression             x = 2.3
array-initialization-expression             [-1..2]
default-argument-expression                 x : 2.3
assignment-expression                       x = 2.3
return-expression


