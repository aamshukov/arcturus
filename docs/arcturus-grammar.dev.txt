// lexical
// -------

comments                            : oneline-comment
                                    | multiline-comment
                                    ;

oneline-comment                     : '#' unicode characters opt end-of-line
                                    | '//' unicode characters opt end-of-line
                                    ;

multiline-comment-opt               : multiline-comment
                                    | e(psilon)
                                    ;

multiline-comment                   : '/* unicode characters opt(except '*/' combination)  multiline-comment-opt  unicode characters opt(except '*/' combination) '*/'
                                    ;



whitespace-characters               : whitespace-character
                                    | whitespace-characters whitespace-character
                                    ;

whitespace-character                : unicode character of class Zs
                                    | horizontal tab character (U+0009)
                                    | vertical tab character (U+000B)
                                    | form feed character (U+000C)
                                    ;

end-of-line                         : \u000D                \r
                                    | \u000A                \n
                                    | \u000D \u000A         \r\n
                                    | \u000A \u000D         \n\r
                                    | \u0085
                                    | \u2028
                                    | \u2029
                                    | end-of-file
                                    ;

end-of-file                         : \u0000
                                    | \u001A
                                    ;

indent                              : '  '       2 spaces
                                    | '    '     4 spaces
                                    | '        ' 8 spaces
                                    ;



// code points
// \u + 4 hex digits - unicode BMP
// \U + 8 hex digits - unicode astral planes (full set)
universal-character-name            : '\u' hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
                                    | '\U' hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
                                    ;

letter-character                    : unicode character of classes Lu, Ll, Lt, Lm, Lo, or Nl
                                    | universal-character-name representing a character of classes Lu, Ll, Lt, Lm, Lo, or Nl
                                    ;

decimal-digit_character             : unicode character of class Nd
                                    | universal-character-name representing a character of class Nd
                                    ;

connecting-character                : unicode character of class Pc
                                    | universal-character-name representing a character of class Pc
                                    ;

combining-character                 : unicode character of classes Mn or Mc
                                    | universal-character-name representing a character of classes Mn or Mc
                                    ;

formatting_character                : unicode character of class Cf
                                    | universal-character-name representing a character of class Cf
                                    ;

binary-digit                        : '0' '1'
                                    ;

octal-digit                         : '0' '1' '2' '3' '4' '5' '6' '7'
                                    ;

nonzero-decimal-digit               : '1' '2' '3' '4' '5' '6' '7' '8' '9'
                                    ;

decimal-digit                       : '0' '1' '2' '3' '4' '5' '6' '7' '8' '9'
                                    ;

hexa-decimal-digit                  : '0' '1' '2' '3' '4' '5' '6' '7' '8' '9' 'a' 'b' 'c' 'd' 'e' 'f' 'A' 'B' 'C' 'D' 'E' 'F'
                                    ;



escape-characters                   : simple-escape-character
                                    | octal-escape-characters
                                    | hexadecimal-escape-characters
                                    ;

simple-escape-character             : '\'' '\"' '\\' '\a' '\b' '\f' '\n' '\r' '\t' '\v'
                                    ;

octal-escape-characters             : '\' octal-digit
                                    | '\' octal-digit octal-digit
                                    | '\' octal-digit octal-digit octal-digit
                                    ;

hexadecimal-escape-characters       : '\x' hexadecimal-digit
                                    | '\x' hexadecimal-digit hexadecimal-digit
                                    | '\x' hexadecimal-digit hexadecimal-digit hexadecimal-digit
                                    | '\x' hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
                                    | '\x' hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
                                    | '\x' hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
                                    | '\x' hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
                                    | '\x' hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
                                    ;

underscore-characters-opt           : underscore-characters
                                    | e(psilon)
                                    ;

underscore-characters               : underscore-character
                                    | underscore-characters underscore-character
                                    ;

underscore-character                : '_' (the underscore character U+005F)
                                    | universal-character-name representing the character U+005F
                                    ;




literal                             : integer-number-literal
                                    | real-number-literal
                                    | string-literal
                                    | boolean-literal
                                    ;

integer-number-literal              : binary-number-literal
                                    | octal-number-literal
                                    | decimal-number-literal
                                    | hexadecimal-number-literal
                                    ;

binary-number-literal               : '0b' binary-digit
                                    | '0B' binary-digit
                                    | binary-number-literal underscore-characters-opt binary-digit
                                    ;

octal-number-literal                : '0'
                                    | octal-number-literal underscore-characters-opt octal-digit
                                    ;

decimal-number-literal              : nonzero-decimal-digit
                                    | decimal-number-literal underscore-characters-opt decimal-digit
                                    ;

decimal-digits-opt                  : decimal-digits
                                    | e(psilon)
                                    ;

decimal-digits                      : decimal-digit
                                    | decimal-digits underscore-characters-opt decimal-digit
                                    ;

hexadecimal-number-literal          : '0x' hexadecimal-digits
                                    | '0X' hexadecimal-digits
                                    ;

hexadecimal-digits-opt              : hexadecimal-digits
                                    | e(psilon)
                                    ;

hexadecimal-digits                  : hexadecimal-digit
                                    | hexadecimal-digits underscore-characters-opt hexadecimal-digit
                                    ;

real-number-literal                 : decimal-real-number-literal
                                    | hexadecimal-real-number-literal
                                    ;

decimal-real-number-literal         : decimal-digits-opt '.' decimal-digits exponent-part-opt
                                    | decimal-digits '.' exponent-part-opt
                                    | decimal-digits exponent-part
                                    ;

exponent-part-opt                   : exponent-part
                                    | e(psilon)
                                    ;

exponent-part                       : 'e' sign-opt decimal-digits
                                    | 'E' sign-opt decimal-digits
                                    ;

hexadecimal-real-number-literal     : '0x' hexadecimal-decimal-digits-opt '.' hexadecimal-decimal-digits binary-exponent-part-opt
                                    | '0X' hexadecimal-decimal-digits-opt '.' hexadecimal-decimal-digits binary-exponent-part-opt
                                    | '0x' hexadecimal-decimal-digits '.' binary-exponent-part-opt
                                    | '0X' hexadecimal-decimal-digits '.' binary-exponent-part-opt
                                    | '0x' hexadecimal-decimal-digits binary-exponent-part
                                    | '0X' hexadecimal-decimal-digits binary-exponent-part
                                    ;

binary-exponent-part-opt            : binary-exponent-part
                                    | e(psilon)
                                    ;

binary-exponent-part                : 'p' sign-opt decimal-digits
                                    | 'P' sign-opt decimal-digits
                                    ;

sign-opt                            : '+'
                                    | '-'
                                    | e(psilon)
                                    ;

string-literal                      : ''' string-characters-opt (except \' (U+0027), \\ (U+005C)) '''
                                    | '"' string-characters-opt (except \" (U+0022), \\ (U+005C)) '"'
                                    | r''' string-characters-opt (except \' (U+0027)) '''
                                    | r'"' string-characters-opt (except \" (U+0022))'"'
                                    ;

string-characters-opt               : string-characters
                                    | e(psilon)
                                    ;

string-characters                   : string-character
                                    | string-characters string-character
                                    ;

string-character                    : unicode character opt
                                    | escape-characters
                                    | universal-character-name
                                    ;

boolean-literal                     : 'true'
                                    | 'false'
                                    ;



identifiers                         : identifier
                                    | identifiers ',' identifier
                                    ;

identifier                          : identifier-start-character identifier-part-characters-opt
                                    ;

identifier-start-character          : letter-character
                                    | underscore-characters
                                    ;


identifier-part-characters          : identifier-part-character
                                    | identifier-part-characters identifier-part-character
                                    ;

identifier-part-character           : letter-character
                                    | decimal-digit-character
                                    | connecting-character
                                    | combining-character
                                    | formatting-character
                                    ;

fully-qualified-name                : identifier
                                    | fully-qualified-name '.' identifier
                                    ;



keyword                             : 'byte' 'integer' 'real' 'string' 'boolean'
                                    | 'true' 'false'
                                    | 'enum'
                                    | 'struct'
                                    | 'const' 'partial'
                                    | 'if' 'else' 'for'
                                    | 'continue' 'break' 'return'
                                    | 'import'
                                    | 'namespace'
                                    | 'is' 'as'?? 'and' 'or' 'not' 'in'
                                    | 'link'?? 'pointer'?? 'reference'?? 'ref'??
                                    | 'lazy'
                                    | 'pass'?? 'noop'??
                                    ;

punctuator                          : ':' '..' '...' ',' '{' '}' '[' ']' '(' ')' '->'??
                                    ;

operator                            : '+' '-' '*' '/' '>>' '<<' '=' '==' '!=' '<' '<=' '>' '>=' '&' '&&' '|' '||' '^'
                                    | 'is' 'as' 'and' 'or' 'not' 'in'
                                    ;

assignment-operator                 : '=' '*=' '/=' '%=' '+=' '-=' '>>=' '<<=' '&=' '^=' '|='
                                    ;



// syntax
// ------

compilation-unit                    : declarations-opt
                                    ;

declarations-opt                    : declarations
                                    | e(psilon)
                                    ;

declarations                        : declaration
                                    | declarations declaration
                                    ;

declaration                         : import-declaration
            namespace-declaration??
                                    | type-declaration
                                    | function-definition
                                    ;



import-declaration                  : 'import' fully-qualified-name end-of-line
                                    ;



type-declaration                    : struct-declaration
                                    ;

struct-declaration                  : identifier type-parameters-opt : 'struct' end-of-line struct-members-opt
                                    ;

struct-members-opt                  : struct-members
                                    | e(psilon)
                                    ;

struct-members                      : struct-member
                                    | struct-members struct-member
                                    ;

struct-member                       : indent identifier ':' integral-type modifiers-opt array-declaration-opt end-of-line
                                    | indent identifier ':' integral-type modifiers-opt array-declaration-opt '=' primary-expression end-of-line
                                    ;

modifiers-opt                       : modifiers
                                    | e(psilon)
                                    ;

modifiers                           : modifier
                                    | modifiers modifier
                                    ;

modifier                            : const-modifier
                                    ;

const-modifier                      : 'const'
                                    ;

array-declaration-opt               : array-declaration
                                    | e(psilon)
                                    ;

array-declaration                   : '[' array-dimensions ']'
                                    | '(' array-dimensions ')'
                                    ;

array-dimensions                    : array-dimension
                                    | array-dimensions ';' array-dimension
                                    ;

array-dimension                     : sign-opt decimal-number-literal
                                    | sign-opt decimal-number-literal '..' sign-opt decimal-number-literal
                                    ;



function-definition                 : identifier type-parameters-opt '(' function-parameters-opt ')' function-return-type-opt end-of-line function-body
                                    ;

function-parameters-opt             : function-parameters
                                    | e(psilon)
                                    ;

function-parameters                 : function-parameter
                                    | function-parameters ',' function-parameter
                                    ;

function-parameter                  : identifier ':' integral-type modifiers-opt array-declaration-opt
                                    | identifier ':' integral-type modifiers-opt array-declaration-opt '=' primary-expression
                                    ;

function-return-type-opt            : function-return-type
                                    | e(psilon)
                                    ;

function-return-type                : '->' integral-type
                                    | '->' fully-qualified-name
                                    ;

function-body                       : variable-declarations
                                    | statements
                                    ;



statements                          : statement
                                    | statements statement
                                    ;

statement                           : declaration-statement
                                    | expression-statement
                                    | selection-statement
                                    | iteration-statement
                                    ;


declaration-statement               : variable-declaration
                                    ;

variable-declaration                : indent identifier ':' integral-type modifiers-opt array-declaration-opt end-of-line
                                    | indent identifier ':' integral-type modifiers-opt array-declaration-opt '=' primary-expression end-of-line
                                    ;

expression-statement                : indent expression end-of-line
                                    ;

selection-statement                 : indent 'if' boolean-expression end-of-line statements
                                    | indent 'if' boolean-expression end-of-line statements 'else' end-of-line statements
                                    ;

iteration-statement                 : indent 'for' expressions 'in' expression end-of-line statements
                                    ;



expressions                         : expression
                                    | expressions ',' expression
                                    ;

expression                          : assignment-expression
                                    ;

boolean-expression                  : expression
                                    ;

assignment-expression               : conditional-expression
                                    | logical-or-expression assignment-operator assignment-expression
                                    ;

conditional-expression              : logical-or-expression
                                    | logical-or-expression '?' expression ':' logical-or-expression
                                    ;

logical-or-expression               : logical-and-expression
                                    | logical-or-expression '||' logical-and-expression
                                    | logical-or-expression 'or' logical-and-expression
                                    ;

logical-and-expression              : inclusive-or-expression
                                    | logical-and-expression '&&' inclusive-or-expression
                                    | logical-and-expression 'and' inclusive-or-expression
                                    ;

inclusive-or-expression             : exclusive-or-expression
                                    | inclusive-or-expression '|' exclusive-or-expression
                                    ;

exclusive-or-expression             : and-expression
                                    | exclusive-or-expression '^' and-expression
                                    ;

and-expression                      : equality-expression
                                    | and-expression '&' equality-expression
                                    ;

equality-expression                 : relational-expression
                                    | equality-expression '==' relational-expression
                                    | equality-expression '!=' relational-expression
                                    ;

relational-expression               : relational-expression '<' shift-expression
                                    | relational-expression '>' shift-expression
                                    | relational-expression '<=' shift-expression
                                    | relational-expression '>=' shift-expression
                                    | relational_expression 'is' type
                                    | relational_expression 'as' type
                                    ;

shift-expression                    : additive-expression
                                    | shift-expression '<<' additive-expression
                                    | shift-expression '>>' additive-expression
                                    ;

additive-expression                 : multiplicative-expression
                                    | additive-expression '+' multiplicative-expression
                                    | additive-expression '-' multiplicative-expression
                                    ;

multiplicative-expression           : unary-expression
                                    | multiplicative-expression '*' unary-expression
                                    | multiplicative-expression '/' unary-expression
                                    | multiplicative-expression '%' unary-expression
                                    ;

unary-expression                    : primary-expression
                                    | '+' unary-expression
                                    | '-' unary-expression
                                    | '!' unary-expression
                                    | '~' unary-expression
                                    | 'not' unary-expression
                                    ;

primary-expression                  : literal
                                    | fully-qualified-name type-arguments-opt
                                    | '(' expression ')'
                                    | primary-expression '(' arguments-opt ')'
                                    ;

arguments-opt                       : arguments
                                    | e(psilon)
                                    ;

arguments                           : argument
                                    | arguments ',' argument
                                    ;

argument                            : argument-name-opt expression
                                    ;

argument-name-opt                   : argument-name
                                    | e(psilon)
                                    ;

argument-name                       : identifier ':'
                                    ;



type                                : integral-type
                                    | fully-qualified-name type-arguments-opt
                                    ;

integral-type-opt                   : integral-type
                                    | e(psilon)
                                    ;

integral-type                       : 'byte'
                                    | 'integer'
                                    | 'real'
                                    | 'string'
                                    | 'boolean'
                                    ;

type-parameters-opt                 : '<' type-parameters '>'
                                    | e(psilon)
                                    ;

type-parameters                     : type-parameter
                                    | type-parameters ',' type-parameter
                                    ;

type-parameter                      : identifier
                                    | identifier '=' literal
                                    | identifier '=' fully-qualified-name type-arguments-opt
                                    ;

type-arguments-opt                  : '<' type-arguments '>'
                                    | e(psilon)
                                    ;

type-arguments                      : type-argument
                                    | type-arguments ',' type-argument
                                    ;

type-argument                       : type
                                    ;




//
compilation composition
    imports all deps into one compilation-unit and then processed

                              program arcturus

                 namespace N1                   namespace N2

    package1                      package2                         package3
        module1                       module1                          module1
        module2                       module2                          module2
        module3                       module3                          module3

    package(physical) - spans compilation-units (might be files) - distribution unit
        modules
            module1 - compilation-unit1 (file)
            ...
            moduleN - compilation-unitN (file)

    namespace(logical) - spans packages



namespace
    namespace sample
        namespace nested
    using sample.nested
    import sample.nested
    a : sample.nested.point

    alias
        using sn = sample.nested
        import sample.nested as sn
    a : sn.point

    namespace n1.n2.n3
        namespace w
    a : n1.n2.n3.w.point



comment
    #  single line comment
    // single line comment
    /* /* miltiline nested comment */ */



declarations:
    let a : integer | string

    byte
        flags: byte = 0xDA
        bits : byte = 0b1_0_00_10_1
        line : byte [0..256]

    boolean
        flag: boolean                               default = false
        flag: boolean = true

    number
        integer
            i, j, k : integer                        uninitialized, all have the same value which is default - 0
            i, j, k : integer = 1_2_345_678_90       initialization, all have the same value
            i, j, k : integer = 1'2'34'5'67'890      initialization, all have the same value
            i, j, k : integer const = 100            initialization of constants, all have the same value, must be assigned
            i, j, k : const integer = 100
            i, j, k : 0                              initialization, all have the same value, type integer is inferred
            i, j, k : const = 100                    initialization of constants, all have the same value, type integer is inferred
            i, j, k : integer readonly               uninitialized variables of read-only constants, might be called later after declaration, all have the same value
            i, j, k : integer readonly = 100         initialization of read-only constants, might be called later after declaration, all have the same value
            i, j, k : readonly integer = 100
            i, j, k : integer -10 .. 100             uninitialized, all have the same range [-10:100], range's bounddary must be const expression
            i, j, k : integer -10 .. 100 = 5         initialized range, initialized with 5, all have the same vaue in the range

            i, j, k = foo()                         deconstruction, types are inferred from foo() return values
            i, j, k = 10

            row/column access (default)
            column/row access
            [] - checked(default)
            () - unchecked
            c  - column based suffix
            a, b, c: integer [1..5]              =  3,4                 ----- checked array, row based
            a, b, c: integer (1..5)              =  3,4                 ----- unchecked array, row based
            a, b, c: integer [1..5; -1..8; 0..4] =  3,4; 2,3,3; 5,6,6   ---- 3D
            a, b, c: integer [1..5; -1..8; 0..4] =  ( 3,4; 2,3,3;
                                                        5,6,6 )
            a, b, c: integer [1..5; -1..8; 0..4] =  ( 3,4; 2,3,3; 5,6,6 )
            a, b, c: integer [1..5, -1..8, 0..4] =  ( (3,4), (2,3,3), (5,6,6) )
            a, b, c: integer [1..5] c            =  3,4                 ----- checked array, column based
            a, b, c: integer (1..5) c            =  3,4                 ----- unchecked array, column based

            a[2, -1, 0] = 5
            a[2, -1, 0] = 5

            a : integer [0..2; 0..3; 0..4] = ( ( ( 3, 4, 2, 3 ), (0, -3, 9, 11), (23, 12, 23, 2) ), ( ( 13, 4, 56, 3 ), ( 5, 9, 3, 5 ), ( 3, 1, 4, 9 ) ) )

            slices, APL?? and python
            slice = a[-1:1; -5:45;]

        real
            θ, φ, π : real
            θ, φ, π : 0.1                           inferred as real
            θ, φ, π : real = 0.1
            θ, φ, π : real const = 0.1
            θ, φ, π : const real = 0.1
            θ, φ, π : real readonly = 0.1
            θ, φ, π : readonly real = 0.1
            π       : real const = 3.14159
            θ, φ    : real -π .. +π                 π must be const expression
            θ, φ    : real -π .. +π = π/2           might be initialized with expression
            θ, φ    : const real -π .. +π = π/2     might be initialized with expression
            θ, φ    : real const -π .. +π = π/2     might be initialized with expression


    string (always represented as unicode codepoint - 32 bits), " '' " or ' "" '
        name, nickname : string
        name, nickname : string = "Art"
        name, nickname : string const = "Art"       must be initialized
        name, nickname : const string = "Art"       must be initialized
        name, nickname : string readonly = "Art"
        name, nickname : readonly string = "Art"

        "path 'c:\\tmp\\arktur\\file.txt' exists"  'path "c:\\tmp\\arktur\\file.txt" exists'
        r"path 'c:\tmp\arktur\file.txt' exists"    r'path "c:\tmp\arktur\file.txt" exists'
        "path is {path}, where path is substitued by variable 'path'"
        r"path is {path}, where path is substitued by variable 'path'"
        "\' \" \n \r \t \\ \b \f \v \017 \x8C \X8C \uD83C\uDF4C \U0001f34c"
        "balance {0:.2f} is as {1:YYMMDD}"              positional
        "balance {amount:.2f} is as {today:YYMMDD}"     keyword
        "balance {0:.2f} is as {1:YYMMDD} for {user}"   positional keyword mixture
        DOES NOT support f-strings (python) or interpolated $"" (c#) strings on purpose (hard to debug)


    enum
        direction enum [integer]
            north,
            east,
            south,
            west

        numbers enum ( one, two, three,
                       forty = 40, fortyone)

        numbers enum string
            ( odin = "1", dva = "2" )  ------------ when non-integer - all must be initialized
        numbers enum real
            ( r1 = 0.23, r2 = 3.45 )   ------------ when non-integer - all must be initialized
        days enum integer ( monday, tuesday, wednesday,
                            thursday, friday, saturday, sunday )
        workdays enum days
            monday .. friday
        weekend enum days
            saturday .. sunday
        weekend enum days ( saturday .. sunday )
        odddays enum days
            monday,
            tuesday .. wednesday,
            friday,
            weekend


    struct [<Ts>][partial] [readonly|const]
            [readonly ------- values can be assigned only once]
            [const ------- values must be assigned in declaration]
            each struct defines one defaulet instance of this struct - static sentinel = default

        point struct
            x : real = 0.0,
            y : real = 0.0,
            z : real = 0.0,
            w : real = 1.0

        point<T> struct
            x : T,
            y : T,
            z : T,
            w : real = 1.0

        point<T> struct
            x, y, z : T
            w : real = 1.0

        point<T> struct ( x : T, y : T,
                          z : T, w : real = 1.0 )

        node<T> struct
            value : T,
            point : point<T>,
            next : node,          ---- when parse mark as ref field, by default it set to the 'default' sentinel
            prev : node

        node<T> struct
            value : T,
            point : point<T>,
            next, prev : node

        tree<T> struct
            gr_symbol : grammar.symbol
            ir_symbol : ir.symbol
            value : T,
            papa : tree
            kids : tree
            flags : byte = 0x00

        status<T, P, R, TSize integer = 64, TWeight real = 1.4, TText string = "message"> struct
            code : T,
            param : P,
            return : R,
            size : TSize,
            weight : TWeight,
            text : TText

        user<T> struct extends tree<T>
            name : string,
            age : integer,
            married : boolean = false,
            status : string = 'active',
            salary : real = 1.0

        manager<T> struct extends user<T>
            occupation : string,
            bonus : real

        boss<T> struct extends manager<T>
            rank : string,
            big_bonus : real

        myboss : boss<string> = ( name = 'Arthur', age = 50, married = true, status = 'active',
                                  salary = 10000000.0, occupation = 'R&D', bonus = 1231211.2,
                                  rank = 'highest', big_bonus = 656545234.923432 )

        pp0 : point<real>
        pp0 : point<real> = ( 1.2, 3.2,
                              5.0, 3.12 )
        pp0 : point<real> = 1.2, 3.2, 5.0, 3.12
        pp1 : point<real> = x = 1.2, y = 3.2, z = 5.0, w = 3.12
        pp2 : point<real> = z = 1.2, w = 3.2, y = 5.0, z = 3.12
        pp2 : point<real> = ( z = 1.2, w = 3.2,
                                y = 5.0, z = 3.12 )
        pp3 : point<real> = ( x = 1.2, w = 3.12 )
        pp4 : point<integer> = ( z = 1 )

        n1 : node<integer> = ( 5, pp4 )
        n1 : node<integer> = ( 5, pp4, default, default )
        n1 : node<integer> = ( value = 5, point = pp4, next = n1, prev = n1 )
        n2 : node<integer> = ( value = 5, point = ( x = 1.2, w = 3.12 ), n2, n1 ) ---
                                                    anonymous struct
        n3 : node<integer> = ( value = 5, point = get_point(), next = n3, prev = n2 )


    callable
        parameters passing method
            by value
                byte, integer, real, boolean
            by ref
                string, array, enum, struct, callable

        function
            func/proc
                name[<T>] func/proc ([params]) [lazy] [ -> (returns) | returns]

                foo func(i : integer, r : real = π, s : string = "", n1 : node<integer> = ( 5, pp4 )) lazy returns i, j, k: integer, pp2 : point<real>
                foo func(i : integer, r : real = π, s : string = "", n1 : node<integer> = ( 5, pp4 )) lazy -> ( i, j, k: integer,
                                                                                                                pp2 : point<real> )
                foo(1)                  ------- after call variables i,j,k and pp2 are avaiable automatically
                i1,j1,k1,pp20 = foo(1)  ------- after call variables i,j,k and pp2 can have different names

                foo<T> func(t : T, r : real = π, s : string = "") lazy -> (i, j, k: T, pp2 : point<T>)
                    body or { body }

                foo<real>(1.23, φ, "test")
                foo<real>(t : 1.23, s : "test", r : φ) lazy??

                foo func(i : integer,
                         r : real = π,
                         s : string = "",
                         n1 : node<integer> = ( 5, pp4 ),
                         ...) ------- variable number of params
                            lazy returns (i, j, k: integer, pp2 : point<real>)
                                 ->
                    body or { body }

                nested
                    num1 func(x : integer) -> integer
                       num2 func(y : integer) -> (integer)
                          return x * y
                       return num2
                    res = num1(10)
                    print(res(5))

                block
                    block ------ new scope
                        ...
                    block ------ new scope
                        ...


        lambda (no templates/generics)
                (t : integer, r : real = π, s : string = "") lazy -> i, j, k: real, pp2 : point<real> => expression body
                (t : integer, r : real = π, s : string = "") lazy -> (i, j, k: real, pp2 : point<real>) => { statements body }


    contracts
        interface


    statement
        selection
            if condition                                    if (condition)      ----- might be split across lines
                statements                                      { statements }  ----- free layout
            else if condition                               else if (condition)
                statements                                      { statements }
            else                                            else
                statements                                      { statements }


        case/switch

case(s):
    when 1
    when 's'
    when a is string || a is real && a is customtype


case Sensor is
    when Elevation => Record_Elevation(Sensor_Value);
    when Azimuth => Record_Azimuth (Sensor_Value);
    when Distance => Record_Distance (Sensor_Value);
    when others => null;
end case;
case Today is
    when Mon => Compute_Initial_Balance;
    when Fri => Compute_Closing_Balance;
    when Tue .. Thu => Generate_Report(Today);
    when Sat .. Sun => null;
end case;
case Bin_Number(Count) is
    when 1 => Update_Bin(1);
    when 2 => Update_Bin(2);
    when 3 | 4 =>
        Empty_Bin(1);
        Empty_Bin(2);
    when others => raise Error;
end case;

pattern matching, case/when, switch C# 8






        iteration
            for k, name in enumerate(names)                 for (k, name) in enumerate(names)
                statements                                      { statements }
            for k in 1..5    ------ next value              for k in 1..5       ------ next value
                statements                                      { statements }

            while condition  ------ expression is true      while (condition)   ------ expression is true
                statements                                      { statements }

            continue
            break
            yield ----- ??
            return
            goto



    expression



